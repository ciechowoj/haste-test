#pragma once
#include <new>
#include <initializer_list>

namespace haste {

using i8 = signed char;
using i16 = signed short;
using i32 = signed int;
using i64 = signed long long;

using u8 = unsigned char;
using u16 = unsigned short;
using u32 = unsigned int;
using u64 = unsigned long long;

using f32 = float;
using f64 = double;

namespace detail {

template <class, class, i32 = sizeof(void*)>
struct _native {};

template <class t32, class t64>
struct _native<t32, t64, 4> {
  using type = t32;
};

template <class t32, class t64>
struct _native<t32, t64, 8> {
  using type = t64;
};
}

using isize = detail::_native<i32, i64>::type;
using usize = detail::_native<u32, u64>::type;

constexpr usize usize_min = 0;
constexpr usize usize_max = ~usize(0);

namespace detail {

template <class T>
struct _remove_reference {
  using type = T;
};

template <class T>
struct _remove_reference<T&> {
  using type = T;
};

template <class T>
struct _remove_reference<T&&> {
  using type = T;
};
}

template <class T>
using remove_reference = typename detail::_remove_reference<T>::type;

template <class T>
remove_reference<T>&& move(T&& x) noexcept {
  return static_cast<remove_reference<T>&&>(x);
}

template <class T>
T&& forward(remove_reference<T>& x) noexcept {
  return static_cast<T&&>(x);
}

template <class T>
T&& forward(remove_reference<T>&& x) noexcept {
  return static_cast<T&&>(x);
}

namespace detail {

using std::begin;
using std::end;

struct true_t {
  constexpr operator bool() const { return true; }
};

struct false_t {
  constexpr operator bool() const { return false; }
};

template <class T>
constexpr auto is_iterable(int)
    -> decltype(std::declval<T&>().begin() != std::declval<T&>().end(), void(),
                ++std::declval<decltype(std::declval<T&>().begin())&>(),
                void(std::declval<T&>().begin()), true_t()) {
  return {};
}

template <class T>
constexpr auto is_iterable(...) -> false_t {
  return {};
}

template <class T>
constexpr auto has_size(int)
    -> decltype(usize(std::declval<T&>().size()), void(), true_t()) {
  return {};
}

template <class T>
constexpr auto has_size(...) -> false_t {
  return {};
}

template <bool>
struct enable_if {};

template <>
struct enable_if<true> {
  using type = int;
};

template <class X, class Y>
struct enable_if_same {};

template <class X>
struct enable_if_same<X, X> {
  using type = int;
};


}

template <class T>
constexpr bool is_iterable = detail::is_iterable<T>(0);

template <class T>
const bool has_size = detail::has_size<T>(0);

template <class T>
using enable_if_iterable = typename detail::enable_if<is_iterable<T>>::type;

template <class T>
using enable_if_sized_iterable =
    typename detail::enable_if<is_iterable<T> && has_size<T>>::type;

template <class T>
using enable_if_unsized_iterable =
    typename detail::enable_if<is_iterable<T> && !has_size<T>>::type;

template <class... X>
using enable_if_same =
    typename detail::enable_if_same<X...>::type;

template <class X>
const X& max(const X& x) {
  return x;
}

template <class X>
const X& max(const X& x, const X& y) {
  return (x < y) ? x : y;
}

template <class X, class... Xs>
const X& max(const X& x, const Xs&... xs) {
  return haste::max(x, haste::max(xs...));
}





//
// enable_if_input_range
// enable_if_forward_range
// enable_if_bidirectional_range
// enable_if_random_access_range
// enable_if_continuous_range
//

}
