#pragma once
#include <haste/panic>
#include <haste/primitive>
#include <utility>

namespace haste {
namespace detail {

void expected_construct_panic();
void expected_panic_panic();
}

template <class T, class E>
class expected {
 public:
  expected(expected<T, E>&& that) : _error(that._error) {
    if (_error == E()) {
      ::new (_value) T(move(that._get_value()));
    }
  }

  expected(const expected<T, E>& that) : _error(that._error) {
    if (_error == E()) {
      new (_value) T(that._get_value());
    }
  }

  expected(T&& value) : _error(E()) { new (_value) T(move(value)); }

  expected(const T& value) : _error(E()) { new (_value) T(value); }

  expected(E&& error) : _error(move(error)) {
    if (error == E()) {
      detail::expected_construct_panic();
    }
  }

  expected(const E& error) : _error(error) {
    if (error == E()) {
      detail::expected_construct_panic();
    }
  }

  ~expected() {
    if (_error == E()) {
      _get_value().~T();
    }
  }

  expected<T, E>& operator=(expected<T, E>&& that) {
    swap(*this, expected<T, E>(that));
    return *this;
  }

  expected<T, E>& operator=(const expected<T, E>& that) {
    swap(*this, expected<T, E>(that));
    return *this;
  }

  explicit operator bool() { return _error == E(); }

  T ignore() && {
    if (_error == E()) {
      return move(_get_value());
    } else {
      return T();
    }
  }

  T ignore() const & {
    if (_error == E()) {
      return _get_value();
    } else {
      return T();
    }
  }

  T panic() && {
    if (_error != E()) {
      detail::expected_panic_panic();
    }

    return move(_get_value());
  }

  T panic() const & {
    if (_error != E()) {
      detail::expected_panic_panic();
    }

    return _get_value();
  }

  E error() const { return _error; }

 private:
  alignas(T) char _value[sizeof(T)];
  E _error;

  T& _get_value() { return *reinterpret_cast<T*>(_value); }

  const T& _get_value() const { return *reinterpret_cast<T*>(_value); }
};

template <class T, class E>
void swap(expected<T, E>& a, expected<T, E>& b) {
  if (a._error == E() && b._error == E()) {
    T temp = move(a._get_value());
    a._get_value() = move(b._get_value());
    b._get_value() = move(temp);
  }
  else if (a._error == E()) {
    new (b._value) T(move(a._get_value()));
    a._get_value().~T();
  }
  else if (b._error == E()) {
    new (a._value) T(move(b._get_value()));
    b._get_value().~T();
  }

  auto temp = move(a._error);
  a._error = move(b._error);
  b._error = move(temp);
}

template <class E> class expected<void, E> {
 public:
  expected() = default;
  expected(expected<void, E>&& that) : _error(that._error) { }
  expected(const expected<void, E>& that) : _error(that._error) { }

  expected(E&& error) : _error(move(error)) {
    if (error == E()) {
      detail::expected_construct_panic();
    }
  }

  expected(const E& error) : _error(error) {
    if (error == E()) {
      detail::expected_construct_panic();
    }
  }

  ~expected() = default;

  expected<void, E>& operator=(expected<void, E>&& that) {
    swap(*this, expected<void, E>(that));
    return *this;
  }

  expected<void, E>& operator=(const expected<void, E>& that) {
    swap(*this, expected<void, E>(that));
    return *this;
  }

  explicit operator bool() { return _error == E(); }

  void ignore() const {
  }

  void panic() const & {
    if (_error != E()) {
      detail::expected_panic_panic();
    }
  }

  E error() const { return _error; }

 private:
  E _error = E();
};

template <class E>
void swap(expected<void, E>& a, expected<void, E>& b) {
  auto temp = move(a._error);
  a._error = move(b._error);
  b._error = move(temp);
}

}
