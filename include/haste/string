#pragma once

namespace haste {

class allocator;

typedef unsigned long long size_t;


class bytes32 {
public:
  bytes32();
  bytes32(const allocator&);
  bytes32(size_t size);
  bytes32(size_t size, const allocator&);
  bytes32(size_t size, char value);
  bytes32(size_t size, char value, const allocator&);
  bytes32(const bytes32&);
  bytes32(bytes32&&);
  ~bytes32();

  bytes32& operator=(const bytes32&);
  bytes32& operator=(bytes32&&);

  void reset();
  void resize(size_t size);
  void resize(size_t size, char value);
  void append(char);
  void append(const bytes32&);
  void append(size_t size, const char* data);
  void insert(size_t index, size_t size, char);
  void insert(size_t index, const bytes32&);
  void insert(size_t index, size_t size, const char* data);
  void remove(size_t index, size_t size);

  struct range {

  };

  void replace(range range, size_t data_size, char);
  void replace(range range, const bytes32&);
  void replace(range range, size_t data_size, const char* data);



  /*const_uchar_xptr data() const { return is_small() ? _data : dsds; }
  uchar_xptr data() { return _data; }*/
  size_t size() const { return _size; }

  // bool is_empty() const { }
  // bool is_small() const { }
private:
  const char* _data;
  size_t _size;
  char _buffer[16];
};



/*
template <class T> class list {


private:
  allocator _allocator;
  size_t _capacity;
  size_t _size;
  T* _data;
};

template <class T, class N> class fixed_list : list {
public:
  fixed_list() : list(fixed_allocator(_pool_size, _pool))


private:

  size_t _size;
  uchar _data[sizeof(T)];
};
*/





}

