#pragma once
#include <haste/primitive>
#include <haste/expected>

namespace haste {

namespace detail {

template <class X, class T = void>
struct _enable_if_const_pchar {};

template <class T>
struct _enable_if_const_pchar<const char*, T> {
  using type = T;
};

template <class X>
using enable_if_const_pchar = typename _enable_if_const_pchar<X>::type;
}

class string;

class string_view {
 public:
  string_view() = default;
  string_view(const string_view&) = default;
  string_view(const string&);
  string_view(decltype(nullptr)) {}
  template <int N>
  string_view(const char (&str)[N]) : _begin(str), _end(str + N) {}

  template <class T, typename = detail::enable_if_const_pchar<T>>
  string_view(T str) {
    _zstring(str);
  }

  usize size() const { return _end - _begin; }
  const char* data() const { return _begin; }

 private:
  void _zstring(const char*);
  const char* _begin = nullptr;
  const char* _end = nullptr;
};

class allocator;

enum class parse_int_error {
  no_error,
  empty_string,
  invalid_char,
  underflow,
  overflow,
};

enum class alloc_error {
  no_error,
  out_of_memory,
};

class string : public list<char> {
 public:
  string();
  string(const allocator&);
  string(const string&);
  string(string&&);
  ~string();

  string(const char* begin, const char* end);


  string& operator=(const string&);
  string& operator=(string&&);

  /* void reset();
  void resize(usize size);
  void resize(char value, usize size);

  void append(char);
  void append(const string&);
  void append(const char* data, usize size);

  void insert(usize index, char, usize size);
  void insert(usize index, const string&);
  void insert(usize index, const char* data, usize size);

  void replace(usize index0, usize size0, char c, usize size1);
  void replace(usize index0, usize size0, const string&);
  void replace(usize index0, usize size0, const char* data1, usize size1);

  void remove(usize index, usize size);

  string format(); */

  // optional<haste::i8, parse_int_error> i8() const; // or expected ? (or
  // validate functions?)
  // optional<haste::i16, parse_int_error> i16() const; // or expected ? (or
  // validate functions?)
  // optional<haste::i32, parse_int_error> i32() const; // or expected ? (or
  // validate functions?)
  // optional<haste::i64, parse_int_error> i64() const; // or expected ? (or
  // validate functions?)

  // expected<haste::u8, parse_int_error> u8() const;
  // expected<haste::u16, parse_int_error> u16() const;
  // expected<haste::u32, parse_int_error> u32() const;
  // expected<haste::u64, parse_int_error> u64() const;

  // expected<haste::f32, parse_float_error> f32() const;
  // expected<haste::f64, parse_float_error> f64() const;

  // haste::f32 f32() const; // return NaN if cannot parse ? (a bit bad idea,
  // someone may expect nan in normal circumstances)

  string strip() &&;
  string rstrip() &&;
  string lstrip() &&;

  generator split();

  // bool startswith(string_view) const;
  // bool endswith(string_view) const;

  /*const_uchar_xptr data() const { return is_small() ? _data : dsds; }
  uchar_xptr data() { return _data; }*/
  usize size() const { return _size; }

  // bool is_empty() const { }
  bool is_small() const {  }
 private:
  const char* _data;
  char _buffer[8];
  usize _offset;
  usize _size;
};

class string_builder {
public:

  expected<void, alloc_error> extend();

  char* data();
  usize size();
};




string repeat(char c, usize n);

bool operator==(string_view, string_view);

struct format_proxy {
  string operator()(...);
};

format_proxy operator"" _format(const char* s, long unsigned int);
}
