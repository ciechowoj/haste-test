#pragma once
#include <haste/v2list>
#include <haste/string>

namespace haste {

namespace detail {

template <usize N, class X, class... Xs>
inline usize ndoffset(const usize* strides, X x, Xs... xs) {
  if constexpr (sizeof...(xs) == 0) {
    return strides[N] * x;
  }
  else {
    return strides[N] * x + ndoffset<N + 1, Xs...>(strides, xs...);
  }
}

}

template <class... Xs>
inline usize ndoffset(const usize* strides, Xs... xs) {
  return ::haste::detail::ndoffset<0> (strides, usize(xs)...);
}

using namespace v2;

enum class ndtype { i8, i16, i32, i64, u8, u16, u32, u64, f32, f64 };

struct ndshape : public ilist<usize> {
  template <class... X> explicit ndshape(const X&... x)
    : ilist<usize>(usize(x)...) { }
};

struct ndstride : public ilist<usize> {
  ndstride(ilist<usize>&& that)
    : ilist<usize>(std::move(that)) { }

  ndstride(const ilist<usize>& that)
    : ilist<usize>(that) { }

  template <class... X> explicit ndstride(const X&... x)
    : ilist<usize>(usize(x)...) { }
};

bool operator==(const ilist<int>& a, const ndshape& b);
bool operator!=(const ilist<int>& a, const ndshape& b);

class ndarray;

template <class T> class ndarray_view {
public:


  template <class... I> T& at(I... i) {
    return *((T*)(_data + ndoffset(_strides, i...)));
  }

  const ndshape& shape() const { return *_shape; }

private:
  const ndshape* _shape;
  const usize* _strides;
  const u8* _data;
  friend class ndarray;
};

class ndarray {
public:
  ndarray();
  ndarray(ndarray&&);
  ndarray(const ndarray&);
  ~ndarray();

  string to_string() const;

  const ndshape& shape() const;
  const ndstride& strides() const;
  ndtype dtype() const;

  usize ndim() const;
  usize size() const;
  usize itemsize() const;
  usize nbytes() const;

  ndarray reshape(v2::ilist<usize>);
  void* data();
  const void* data() const;

  ndarray& operator=(ndarray&&) = delete;
  ndarray& operator=(const ndarray&) = delete;

  template <class T> ndarray_view<T> view() {
    auto view = ndarray_view<T>();
    view._shape = &shape();
    view._strides = strides().data();
    view._data = (u8*)data();
    return view;
  }

  static ndarray zeros(ndshape, ndtype);
  static ndarray empty(ndshape, ndtype);
  static ndarray empty(allocator, ndshape, ndtype);

private:
  char _impl[64];
};




}
