#pragma once
#include <haste/allocator>

namespace haste {
namespace detail {

struct allocator_storage {
  alignas(allocator) char _data[sizeof(allocator)] = {0};
};

struct trivial_list {
  trivial_list() = default;
  trivial_list(trivial_list&&);
  trivial_list(const trivial_list&);
  trivial_list(usize, allocator&&);
  trivial_list(usize, usize, allocator&&);
  ~trivial_list();

  trivial_list& operator=(trivial_list&&);
  trivial_list& operator=(const trivial_list&);

  template <class T>
  void init(const T* begin, const T* end) {
    init(begin, (end - begin) * sizeof(T));
  }

  template <class T, class I>
  void unsized_init(I&& iterable) {
    usize size = 0;
    usize capacity = this->size();
    T* data = (T*)this->data();

    for (auto&& x : iterable) {
      if (capacity == size) {
        capacity = expand(size, sizeof(T));
        data = (T*)this->data();
      }

      new (data + size) T(x);
      ++size;
    }

    shrink(size, sizeof(T));
  }

  template <class T, class I>
  void sized_init(I&& iterable) {
    usize itr = 0;
    T* data = (T*)this->data();

    for (auto&& x : iterable) {
      new (data + itr) T(x);
      ++itr;
    }
  }

  template <class T>
  void deinit() {}

  void init(const void*, usize);
  usize expand(usize, usize);
  void shrink(usize, usize);
  void swap(trivial_list& that);

  void view(void*, usize) const;

  usize size() const;
  void* data();
  const void* data() const;
  haste::allocator allocator() const;

  trivial_list steal(usize);
  trivial_list clone(usize) const;
  trivial_list slice(usize, usize, usize) const;

  allocator_storage _allocator_storage;
  u8* _data = nullptr;
  usize _offset = 0;
  usize _size = 0;
};

struct default_list {
  default_list() = default;
  default_list(trivial_list&&);
  default_list(const trivial_list&);
  default_list(usize, usize);
  default_list(usize, usize, allocator&&);
  ~default_list();

  template <class T>
  void deinit() {
    auto data = (T*)_data;
    for (usize i = 0; i < _size; ++i) {
      (data + i)->~T();
    }
  }

  template <class T>
  void init(const T* begin, const T* end) {
    auto data = (T*)_data;
    for (usize i = 0, s = end - begin; i < s; ++i) {
      new (data + i) T(begin[i]);
    }
  }

  usize size() const { return _size; }
  void* data() { return _data; }
  const void* data() const { return _data; }

  u8* _data = nullptr;
  usize _offset = 0;
  usize _size = 0;
};

template <class T, bool = __is_trivially_copyable(T)>
struct _basic_list {
  using type = trivial_list;
};

template <class T>
struct _basic_list<T, false> {
  using type = default_list;
};

template <class T>
using basic_list = typename _basic_list<T>::type;
}

template <class T>
class list_view {
 public:
  list_view() = default;

  T* begin() { return _begin; }
  const T* begin() const { return _begin; }
  T* end() { return _end; }
  const T* end() const { return _end; }
  T* data() { return _begin; }
  const T* data() const { return _begin; }
  usize size() const { return _end - _begin; }

 private:
  T* _begin = nullptr;
  T* _end = nullptr;
};

template <class T>
class list : private detail::basic_list<T> {
 private:
  using _base = detail::basic_list<T>;

 public:
  list() = default;
  list(list<T>&& that) = default;
  list(const list<T>& that) : _base(that._base::clone(sizeof(T))) {}
  list(list<const T>&& that);
  list(const list<const T>& that);
  list(_base&& that) : _base(move(that)) {}
  list(const _base& that) : _base(that) {}

  list(haste::allocator allocator)
      : detail::basic_list<T>(0, sizeof(T), move(allocator)) {}

  list(const std::initializer_list<T>& that)
      : detail::basic_list<T>(that.size(), sizeof(T), allocator()) {
    _base::init(that.begin(), that.end());
  }

  list(haste::allocator allocator, const std::initializer_list<T>& that)
      : detail::basic_list<T>(that.size(), sizeof(T), move(allocator)) {
    _base::init(that.begin(), that.end());
  }

  template <class I>
  list(I&& iterable, enable_if_sized_iterable<I> = 0)
      : detail::basic_list<T>(sizeof(T), allocator()) {
    _base::template sized_init<T>(iterable);
  }

  template <class I>
  list(I&& iterable, enable_if_unsized_iterable<I> = 0)
      : detail::basic_list<T>(sizeof(T), allocator()) {
    _base::template unsized_init<T>(iterable);
  }

  ~list() { _base::template deinit<T>(); }

  list& operator=(list&& that) {
    _base::operator=(move(that));
    return *this;
  }

  list& operator=(const list& that) {
    _base::operator=(that);
    return *this;
  }

  usize size() const { return _base::size(); }
  T* data() { return (T*)_base::data(); }
  const T* data() const { return (const T*)_base::data(); }

  list<T> extend() const;

  static list<T> uninitialized_inplace_list() {
    return _base(typename _base::max_inplace_t(), sizeof(T), allocator());
  }

  template <class U>
  friend class list;
};

template <class T>
class list<const T> : private detail::basic_list<T> {
 private:
  using _base = detail::basic_list<T>;

 public:
  list() = default;
  list(list<T>&& that) : _base(move(that)) {}
  list(const list<T>& that) : _base(that.clone(sizeof(T))) {}
  list(list<const T>&& that) = default;
  list(const list<const T>& that) = default;
  list(_base&& that) : _base(move(that)) {}
  list(const _base& that) : _base(that) {}

  list(haste::allocator allocator)
      : detail::basic_list<T>(sizeof(T), move(allocator)) {}

  list(const std::initializer_list<T>& that)
      : detail::basic_list<T>(that.size(), sizeof(T), allocator()) {
    _base::init(that.begin(), that.end());
  }

  list(haste::allocator allocator, const std::initializer_list<T>& that)
      : detail::basic_list<T>(that.size(), sizeof(T), move(allocator)) {
    _base::init(that.begin(), that.end());
  }

  list(const T* begin, const T* end)
      : detail::basic_list<T>(end - begin, sizeof(T), allocator()) {
    _base::init(begin, end);
  }

  ~list() { _base::template deinit<T>(); }

  list& operator=(list&& that) {
    _base::operator=(move(that));
    return *this;
  }

  list& operator=(const list& that) {
    _base::operator=(that);
    return *this;
  }

  usize size() const { return _base::size(); }
  T* data() { return (T*)_base::data(); }
  const T* data() const { return (const T*)_base::data(); }

  list<const T> clone() &&;
  list<const T> clone() const&;

  list<const T> slice(usize begin, usize end) const {
    return _base::slice(begin, end, sizeof(T));
  }

  list_view<const T> view() const {
    auto result = list_view<const T>();
    _base::view(&result, sizeof(T));
    return result;
  }

  template <class U>
  friend class list;
};

template <class T>
list<T>::list(list<const T>&& that)
    : _base(move(that)._base::steal(sizeof(T))) {}

template <class T>
list<T>::list(const list<const T>& that)
    : _base(that._base::clone(sizeof(T))) {}

template <class T>
class list_builder {};

template <class A, class B>
bool operator==(const list<A>& a, const list<B>& b) {
  auto a_size = a.size();
  auto b_size = b.size();

  if (a_size != b_size) {
    return false;
  }

  auto a_data = a.data();
  auto b_data = b.data();

  for (usize i = 0; i < a_size; ++i) {
    if (a_data[i] != b_data[i]) {
      return false;
    }
  }

  return true;
}
}
