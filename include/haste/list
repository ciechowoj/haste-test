#pragma once
#include <haste/allocator>

namespace haste {
namespace detail {

struct allocator_storage {
  alignas(allocator) char _data[sizeof(allocator)] = {0};
};

struct trivial_list {
  trivial_list() = default;
  trivial_list(trivial_list&&);
  trivial_list(const trivial_list&);
  trivial_list(usize, allocator&&);
  trivial_list(usize, usize);
  trivial_list(usize, usize, allocator&&);
  ~trivial_list();

  trivial_list& operator=(trivial_list&&);
  trivial_list& operator=(const trivial_list&);

  template <class t>
  void destroy() {}

  allocator_storage _allocator_storage;
  u8* _data = nullptr;
  usize _offset = 0;
  usize _size = 0;

  enum mode_t : u8 {
    small_opt = 0,
    has_alloc = 1,
    uses_heap = 2,
  };

  static constexpr usize mode_offset = sizeof(usize) * 8 - 2;
  static constexpr usize mode_mask = ~(usize(3u) << mode_offset);
  static constexpr usize inplace_offset = (sizeof(usize) - 1) * 8;
  static constexpr usize inplace_mask = (~usize(0u) << 8 >> 8) | ~mode_mask;
  static constexpr usize max_inplace = sizeof(usize) * 4 - 1;

  mode_t mode() const { return mode_t(_size >> mode_offset); }
  void set_mode(mode_t mode) {
    _size = (_size & mode_mask) | usize(mode) << mode_offset;
  }

  usize size() const { return mode() == uses_heap ? _size & mode_mask : inplace_size(); }
  void set_size(usize size) { _size = (_size & ~mode_mask) | size; }
  usize inplace_size() const { return (_size & mode_mask) >> inplace_offset; }
  void set_inplace_size(usize size) {
    _size = (_size & inplace_mask) | (size << inplace_offset);
  }

  void* data() {
    switch (mode()) {
      case small_opt:
        return this;
      case has_alloc:
        return &_data;
      default:
        return _data;
    }
  }

  const void* data() const { return ((trivial_list*)this)->data(); }

  allocator& local_allocator() { return (allocator&)_allocator_storage; }
  const allocator& local_allocator() const {
    return (const allocator&)_allocator_storage;
  }
};

struct default_list {
  default_list() = default;
  default_list(trivial_list&&);
  default_list(const trivial_list&);
  default_list(usize, usize);
  default_list(usize, usize, allocator&&);
  ~default_list();

  template <class T>
  void destroy() {
    auto data = (T*)_data;
    for (usize i = 0; i < _size; ++i) {
      (data + i)->~T();
    }
  }

  usize size() const { return _size; }
  void* data() { return _data; }
  const void* data() const { return _data; }


  u8* _data = nullptr;
  usize _offset = 0;
  usize _size = 0;
};

template <class T, bool = __is_trivially_copyable(T)>
struct _basic_list {
  using type = trivial_list;
};

template <class T>
struct _basic_list<T, false> {
  using type = default_list;
};

template <class T>
using basic_list = typename _basic_list<T>::type;
}

template <class T>
class list : private detail::basic_list<T> {
 private:
  using _base = detail::basic_list<T>;

 public:
  list() = default;
  list(list&& that) = default;
  list(const list& that) = default;

  list(haste::allocator allocator)
      : detail::basic_list<T>(sizeof(T), move(allocator)) {}

  list(const std::initializer_list<T>& that)
      : detail::basic_list<T>(that.size(), sizeof(T)) {
    auto dst = this->data();
    auto src = that.begin();
    for (usize i = 0; i < that.size(); ++i) {
      new (dst + i) T(src[i]);
    }
  }

  list(haste::allocator allocator, const std::initializer_list<T>& that)
      : detail::basic_list<T>(that.size(), sizeof(T), move(allocator)) {
    auto dst = this->data();
    auto src = that.begin();
    for (usize i = 0; i < that.size(); ++i) {
      new (dst + i) T(src[i]);
    }
  }

  ~list() { _base::template destroy<T>(); }

  usize size() const { return _base::size(); }
  T* data() { return (T*)_base::data(); }
  const T* data() const { return (const T*)_base::data(); }
};

/*template <class T>
class list : private detail::_erased<T> {
 public:
  list() = default;
  list(allocator& allocator) : _list(allocator) {}
  ~list() {}



  list(list<T>&& that) : _list(that, _move) {}
  list(const list<T>& that) : _list(that, _copy) {}


  template <class... U>
  list(haste::allocator& allocator, const U&... those) : _list(allocator) {
    const void* ptrs[] = {nullptr, &those...};
    _list.init(ptrs + 1, sizeof...(those), sizeof(T), _erased::copy);
  }

  list& operator=(list<T>&& that) {
    swap(_list, move(that._list));
    return *this;
  }

  list& operator=(const list<T>& that) {
    swap(_list, _list(that.list, _erased::copy));
    return *this;
  }

 private:
  char* _data = nullptr;
  usize _unused = 0;
  usize _offset = 0;
  usize _size = 0;
};*/

template <class T>
class list_view {};

template <class T>
class list_builder {};
}
